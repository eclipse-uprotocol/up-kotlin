= Communication Layer APIs (uP-L2 Interface)

The following folder include the client-facing  https://github.com/eclipse-uprotocol/up-spec/tree/main/up-l2[communication layer (uP-L2)] interfaces to implement the publisher/subscriber, notification, and RPC patterns on top of the transport layer (uTransport) API.


== uP-L2 Interfaces

.Interfaces (uP-L2 Interface)
[cols="1,1,3",options="header"]
|===
| Interface | Implementation(s) | Description

| xref:Publisher.kt[*Publisher*] | xref:SimplePublisher.kt[SimplePublisher] | Producers API to send publish or notification messages
| xref:RpcClient.kt[*RpcClient*] | xref:InMemoryRpcClient.kt[InMemoryRpcClient] | Client interface to invoke a method
| xref:RpcServer.kt[*RpcServer*] | xref:InMemoryRpcServer.kt[InMemoryRpcServer]| Server interface to register a listener for incoming RPC requests and automatically send a response
| xref:Notifier.kt[*Notifier*] | xref:SimpleNotifier.kt[SimpleNotifier] | Notification communication pattern APIs to notify and register a listener to receive the notifications
| All the above | xref:UClient.kt[UClient] | Single class that Implements all the interfaces above using the various implementations also from above
|===


== Examples

The uP-L2 interfaces are designed to be used by uEs (applications and services) that rely on the communication patterns to talk with other uEs. The interfaces only require an implementation of uTransport passed by reference to the various APIs to perform the various communication patterns. The Next section we will provide examples of how to use the uP-L2 interfaces to take advantage of the publisher/subscriber, notification, and RPC patterns.

NOTE: Examples below will be using the `UClient` implementation.

=== Publish a Message
[source,kotlin]
----
// Topic to publish
val topic = uUri {
    ueId = 4
    ueVersionMajor = 1
    resourceId = 0x8000
 }
val publisher: Publisher = UClient(/* UTransport Instance */)
val result= publisher.publish(topic) // Send the publish message
----

=== Subscribe and Unsubscribe
[source,kotlin]
----
// Subscription Topic
val topic = uUri {
    ueId = 4
    ueVersionMajor = 1
    resourceId = 0x8000
}
// Listener to process incoming events on the topic
val listener = UListener { message->
        // Handle receiving published messages here
        // do something
}
// Optional handler that is called whenever the SubscriptionState changes for the subscriber
// to the specific topic
val handler = SubscriptionChangeHandler { topic, status->
    // Handle subscription status changes if you're interested like when
    // the subscription state changes from SUBSCRIBE_PENDING to SUBSCRIBED
}

val subscriber: Subscriber = UClient(/* UTransport Instance */)

subscriber.subscribe(topic, listener, handler = handler)

// ... do something else

// Unsubscribe from the topic
subscriber.unsubscribe(topic, listener)
----


=== Invoke a Method using RpcClient
[source,kotlin]
----
// URI of the method to be invoked
val method = uUri {
    ueId = 4
    ueVersionMajor = 1
    resourceId = 3
}
val rpcClient: RpcClient = UClient(/* UTransport Instance */)

// Invoke command without payload, what is returned is a response
// The CompletionStage is completed successfully when the response is received from the server and
// completed exceptionally if an error occurred where the exception is a UStatusException that contains
// the UCode and message of the error.
val result = rpcClient.invokeMethod(method, UPayload.EMPTY, CallOptions.DEFAULT)
----

=== Register and Handle RPC Requests
[source,kotlin]
----
// The method we want to serve
val methodUri = uUri {
    ueId = 4
    ueVersionMajor = 1
    resourceId = 3
}
// Handler for processing requests
val handler  = RequestHandler { request->
    // If your processing of the request was successful, you return the response message like
    // return UPayload.EMPTY
    //
    // If your processing of the request failed, you can throw a UStatusException passing the
    // appropriate UCode and message such as:
    // throw UStatusException(UCode.FAILED_PRECONDITION, "Failed to process the request")
    //
    // For this example, we will return an empty response
    UPayload.EMPTY
}

val server = RpcServer.create(/* UTransport Instance */)

// Register the Request handler that will be called when a request is received
server.registerRequestHandler(methodUri, handler)
----


=== Send a Notification
[source,kotlin]
----
// Notification topic
val topic = uUri {
    ueId = 4
    ueVersionMajor = 1
    resourceId = 0x8000
}
// Destination for the notification
val destination = uUri {
    ueId = 3
    ueVersionMajor = 1
}
val notifier : Notifier = UClient(/* UTransport Instance */)

// Send the notification (without payload)
val result = notifier.notify(topic, destination)
/* handle result here */
----

=== Registering to Receive Notifications
[source,kotlin]
----
val listener = UListener { message->
    // Handle receiving notifications here
    // do something
}
val notifier : Notifier = UClient(/* UTransport Instance */)

// Register listener to receive notifications
val result = notifier.registerNotificationListener(topic, listener)
----

